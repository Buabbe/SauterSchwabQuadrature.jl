{
    "docs": [
        {
            "location": "/", 
            "text": "SauterSchwabQuadrature.jl\n\n\nThis package can be used to solve problems of following type:\n\n\n\n\n\n\\int_{\\Gamma}\\int_{\\Gamma'}b_i(\\textbf{x})\\,k(\\textbf{x},\\textbf{y})\\, b_j(\\textbf{y})\\;da_\\textbf{y}\\,da_\\textbf{x}\n\n\n\n\n\nThe above expression is a double area-integral over two triangles (curved or flat) $\\Gamma$ and $\\Gamma'$ in 3D Space. The integrand consists of two basisfunctions $b_i(\\textbf{x})$ and $b_i(\\textbf{y})$ and the kernel $k(\\textbf{x},\\textbf{y})$.   \n\n\nThis kind of integral appears in the area of Boundary Element Methods for solving elliptic partial differential equations, and can be interpreted as the interaction of the two basisfunctions with respect to their triangles. For this reason in this package $\\Gamma$ is called the testtriangle and $\\Gamma'$ the sourcetriangle, and the same goes for the two basisfunctions; they are called test- and sourcefunction. The triangles correspond to the cells of a meshed surface.\n\n\nAs the solving algorithm works for a wide range of basisfunctions and kernels, all the requirements for the kernel, basisfunctions and the integration areas will be given:\n\n\n1.Requirements for the triangles:\n\n\n\n\nThe triangles are created by three vertices\n\n\nThe triangles must be either the same, have two vertices in common, have one vertex in common or do not touch at all; A partial overlap is forbidden\n\n\n\n\n2.Requirements for the basisfunctions:\n\n\n\n\nThe basisfunctions must be real and non singular on their respective triangles\n\n\nThe basisfunctions map vectors on scalars\n\n\n\n\n3.The kernel must be Cauchy-Singular\n\n\nDepending on the input data, two different implementations of the integral are contained in this package. The first one is very convenient to handle, and does not need a parameterization; but it works only for flat triangles, and the user has to be familiar with the functions \nsimplex()\n and \npoint()\n of the package CompScienceMeshes. For more information about CompScienceMeshes and its functions, the user should visit its GitHub page (https://github.com/krcools/CompScienceMeshes.jl) and its documentation (https://krcools.github.io/CompScienceMeshes.jl/latest/). The second implementation contains only the integration rules; so the user has to build the parameterization by himself, but therefore it also works for curved triangles.\n\n\nBoth implementations are called by a function, which looks like:  \n\n\nfunction(sourcechart, testchart, integrand, information)\n\n\nsourcechart\n and \ntestchart\n are the mappings from a reference triangle (parameterization) to the real (physical) triangles in space. \nintegrand\n is the integrand, and the last argument contains information about how accurate the integration shall be done, and the type of integration.\n\n\nOn the pages 'Non-Parameterized' and 'Parameterized', the user will find more information about the two implementations, and how to operate those.\n\n\nAs soon as this package is added to a local machine, CompScinceMeshes will be added as well.  \n\n\nThis documentation does not derive the integration rules, and how the integration is done, it only shows how to handle this package. If the user wants to know more about how this package operates, he has to go inside the src folder and look up for the book quoted in the README file.", 
            "title": "Home"
        }, 
        {
            "location": "/#sauterschwabquadraturejl", 
            "text": "This package can be used to solve problems of following type:   \n\\int_{\\Gamma}\\int_{\\Gamma'}b_i(\\textbf{x})\\,k(\\textbf{x},\\textbf{y})\\, b_j(\\textbf{y})\\;da_\\textbf{y}\\,da_\\textbf{x}   The above expression is a double area-integral over two triangles (curved or flat) $\\Gamma$ and $\\Gamma'$ in 3D Space. The integrand consists of two basisfunctions $b_i(\\textbf{x})$ and $b_i(\\textbf{y})$ and the kernel $k(\\textbf{x},\\textbf{y})$.     This kind of integral appears in the area of Boundary Element Methods for solving elliptic partial differential equations, and can be interpreted as the interaction of the two basisfunctions with respect to their triangles. For this reason in this package $\\Gamma$ is called the testtriangle and $\\Gamma'$ the sourcetriangle, and the same goes for the two basisfunctions; they are called test- and sourcefunction. The triangles correspond to the cells of a meshed surface.  As the solving algorithm works for a wide range of basisfunctions and kernels, all the requirements for the kernel, basisfunctions and the integration areas will be given:  1.Requirements for the triangles:   The triangles are created by three vertices  The triangles must be either the same, have two vertices in common, have one vertex in common or do not touch at all; A partial overlap is forbidden   2.Requirements for the basisfunctions:   The basisfunctions must be real and non singular on their respective triangles  The basisfunctions map vectors on scalars   3.The kernel must be Cauchy-Singular  Depending on the input data, two different implementations of the integral are contained in this package. The first one is very convenient to handle, and does not need a parameterization; but it works only for flat triangles, and the user has to be familiar with the functions  simplex()  and  point()  of the package CompScienceMeshes. For more information about CompScienceMeshes and its functions, the user should visit its GitHub page (https://github.com/krcools/CompScienceMeshes.jl) and its documentation (https://krcools.github.io/CompScienceMeshes.jl/latest/). The second implementation contains only the integration rules; so the user has to build the parameterization by himself, but therefore it also works for curved triangles.  Both implementations are called by a function, which looks like:    function(sourcechart, testchart, integrand, information)  sourcechart  and  testchart  are the mappings from a reference triangle (parameterization) to the real (physical) triangles in space.  integrand  is the integrand, and the last argument contains information about how accurate the integration shall be done, and the type of integration.  On the pages 'Non-Parameterized' and 'Parameterized', the user will find more information about the two implementations, and how to operate those.  As soon as this package is added to a local machine, CompScinceMeshes will be added as well.    This documentation does not derive the integration rules, and how the integration is done, it only shows how to handle this package. If the user wants to know more about how this package operates, he has to go inside the src folder and look up for the book quoted in the README file.", 
            "title": "SauterSchwabQuadrature.jl"
        }, 
        {
            "location": "/Non-Parameterized/", 
            "text": "Non-Parameterized\n\n\nThe called function in this implementation looks like:\n\n\nsauterschwabintegral(sourcechart, testchart, integrand, accuracy, accuracy_pd)\n.\n\n\nsourcechart\n and \ntestchart\n can be created by\n\n\ntestchart = simplex(P1,P2,P3); sourcechart = simplex(P4,P5,P6)\n.\n\n\nThe order of the input arguments within the \nsimplex()\n function does not matter.\n\n\nsimplex()\n generates the mapping and needs input arguments of type \nSVector{3,Float64}\n; the points P1 to P6 can be created by\n\n\nP = point(x,y,z)\n.\n\n\nx\n, \ny\n and \nz\n are the coordinates of that particular point and \npoint()\n creates a position vector which is of type \nSVector{3,Float64}\n.\n\n\nThe \nintegrand\n must be defined as a function with two input arguments; the input arguments must be 3D vectors. The function name is the input argument.\n\n\nLater the last argument \naccuracy\n will be discussed.\n\n\nSince \nsimplex()\n and \npoint()\n are functions of CompScienceMeshes, CompScienceMeshes does not just have to be installed on the user's machine, but also be available in the current workspace, the same applies for this package as well. The two packages can be made available by\n\n\nusing SauterSchwabQuadrature\n and \nusing CompScienceMeshes\n.\n\n\nThose two commands must always be run at the beginning if using this type of implementation.\n\n\nsauterschwabintegral()\n first modifies \ntestchart\n and \nsourcechart\n with respect to the order of the arguments within their \nsimplex()\n functions; and secondly \u2013 depending on how many vertices both charts have in common \u2013 it generates an object of some type, which contains the information of the accuracy, and the integration strategy. After all of that have been done, this function will call another function with input arguments of the two modified charts, the original integrand, and that new object.\n\n\nTo understand the arguments \naccuracy\n and \naccuracy_pd\n and the examples stored in the example folder, the 'another called function' will be presented next:\n\n\n\n\nIntegration\n\n\nAccording to item 1 on the homepage, four different constellations of the two triangles are possible:\n\n\n\n\nEqual triangles $\\to$ Common Face\n\n\nTwo vertices in common $\\to$ Common Edge\n\n\nOne vertex in common $\\to$ Common Vertex\n\n\nBoth triangles do not touch at all $\\to$ Positive Distance\n\n\n\n\n\n\nAs each of those four constellations has its own integration method (because of a possible singularity in the kernel), the function \nsauterschwabintegral()\n has to call another function, which handles the situation suitably; hence it has four methods.\n\n\nIn the case \nsauterschwabintegral()\n has to deal with a situation mentioned in the first three cases, the two area-integrals will be transformed to four 1D integrals from zero to one; \naccuracy\n gives the number of quadrature points on that integration path, therefore \naccuracy\n is of type unsigned Int64. In the case \nsauterschwabintegral()\n has to deal with a situation of the last case, \naccuracy_pd\n \u2013 which is again a type of unsigned Int64 \u2013 will be considered. It is a rule of how many quadrature points are created on both triangles. \naccuracy_pd\n =\n\n\n\n\n1 $\\to$ 1\n\n\n2 $\\to$ 3\n\n\n3 $\\to$ 4\n\n\n4 $\\to$ 6\n\n\n5 $\\to$ 7\n\n\n6 $\\to$ 12\n\n\n7 $\\to$ 13\n\n\n8 $\\to$ 36\n\n\n9 $\\to$ 79\n\n\n10 $\\to$ 105\n\n\n11 $\\to$ 120\n\n\n12 $\\to$ 400\n\n\n13 $\\to$ 900\n\n\n\n\nquadrature point(s) is(are) created on both triangles.  \n\n\nThe user is now able to understand the examples in the '...non_parameterized.jl' files, rather their titles. The order of the points within the two \nsimplex()\n functions of \nSourcechart\n and \nTestchart\n can be changed arbitrarily, the result will always remain the same. For those who are interested in the 'called function' or want to skip \nsauterschwabintegral()\n and call the integration directly \u2013 which is actually only a sorting process \u2013 may read on now.  \n\n\nThe called function by \nsauterschwabintegral()\n is:\n\n\nsauterschwab_nonparameterized(sourcechart, testchart, integrand, method)\n.\n\n\nsourcechart\n and \ntestchart\n are the modified versions of the original charts, the \nintegrand\n is the same as at the beginning, and \nmethod\n is that created object. The type of \nmethod\n is responsible for which method of \nsauterschwab_nonparameterized\n is applied. The four methods will be listed now:\n\n\n\n\nCommon Face\n\n\n$\\Gamma$ and $\\Gamma'$ are equal, hence \nsourcechart\n and \ntestchart\n are equal as well. The two charts have to be created by\n\n\ntestchart = sourcechart = simplex(P1,P2,P3)\n,\n\n\nwhere \nP1\n, \nP2\n and \nP3\n are the vertices of that particular triangle. Note that both charts must be equal, that means that the first argument of both charts must be equal, the second argument of both charts must be equal, and the last argument of both charts must be equal.\n\n\nThe last argument can be created by\n\n\ncf = CommonFace(x)\n.\n\n\ncf\n is an object of type \nCommonFace()\n, x is the number of quadrature points on the integration path $[0,1]$.\n\n\nAn example of this case can be found at the end of the common_face_non_parameterized.jl file in the example folder.\n\n\n\n\nCommon Edge\n\n\n$\\Gamma$ and $\\Gamma'$ are now different, hence \nsourcechart\n and \ntestchart\n are different as well. The two charts have to be created in the following manner:\n\n\ntestchart = simplex(P1,P2,P3); sourcechart = simplex(P1,P4,P3)\n.\n\n\nAgain the order of the input arguments must be taken into account: The first argument of both charts must be equal, and the last argument of both charts must be equal. Consequently the first and the last argument are the vertices which both triangles have in common.\n\n\nThe last argument can be created by\n\n\nce = CommonEdge(x)\n.\n\n\nce\n is an object of type \nCommonEdge()\n, x is the number of quadrature points on the integration path $[0,1]$.\n\n\nAn example of this case can be found at the end of the common_edge_non_parameterized.jl file in the example folder.\n\n\n\n\nCommon Vertex\n\n\nThe two triangles and charts are again different. The two charts have to be created in the following manner:\n\n\nsourcechart = simplex(P1,P2,P3); testchart = simplex(P1,P4,P5)\n.\n\n\nAgain the order of the input arguments must be taken into account: The first argument of both charts must be equal, the order of \nP2\n and \nP3\n with respect to \nsourcechart\n and the order of \nP4\n and \nP5\n with respect to \ntestchart\n does not matter.  Consequently, the first argument is the vertex both triangles have in common.\n\n\nThe last argument is created by\n\n\ncv = CommonVertex(x)\n.\n\n\ncv\n is an object of type \nCommonVertex()\n, x is the number of quadrature points on the integration path $[0,1]$.\n\n\nAn example of this case can be found at the end of the common_vertex_non_parameterized.jl file in the example folder.\n\n\n\n\nPositive Distance\n\n\nAs the triangles do not touch at all, the integration becomes a simple quadrature. Therefore the order of the arguments within the two \nsimplexfunction()\n's no longer matter.\n\n\nThe last argument can be created by\n\n\npd = PositiveDistance(x)\n.\n\n\npd\n is an object of type \nPositiveDistance()\n, x is the rule of how many quadrature points are created on both triangles.\n\n\nAn example of this case can be found at the end of the positive_distance_non_parameterized.jl file in the example folder.", 
            "title": "Non-Parameterized"
        }, 
        {
            "location": "/Non-Parameterized/#non-parameterized", 
            "text": "The called function in this implementation looks like:  sauterschwabintegral(sourcechart, testchart, integrand, accuracy, accuracy_pd) .  sourcechart  and  testchart  can be created by  testchart = simplex(P1,P2,P3); sourcechart = simplex(P4,P5,P6) .  The order of the input arguments within the  simplex()  function does not matter.  simplex()  generates the mapping and needs input arguments of type  SVector{3,Float64} ; the points P1 to P6 can be created by  P = point(x,y,z) .  x ,  y  and  z  are the coordinates of that particular point and  point()  creates a position vector which is of type  SVector{3,Float64} .  The  integrand  must be defined as a function with two input arguments; the input arguments must be 3D vectors. The function name is the input argument.  Later the last argument  accuracy  will be discussed.  Since  simplex()  and  point()  are functions of CompScienceMeshes, CompScienceMeshes does not just have to be installed on the user's machine, but also be available in the current workspace, the same applies for this package as well. The two packages can be made available by  using SauterSchwabQuadrature  and  using CompScienceMeshes .  Those two commands must always be run at the beginning if using this type of implementation.  sauterschwabintegral()  first modifies  testchart  and  sourcechart  with respect to the order of the arguments within their  simplex()  functions; and secondly \u2013 depending on how many vertices both charts have in common \u2013 it generates an object of some type, which contains the information of the accuracy, and the integration strategy. After all of that have been done, this function will call another function with input arguments of the two modified charts, the original integrand, and that new object.  To understand the arguments  accuracy  and  accuracy_pd  and the examples stored in the example folder, the 'another called function' will be presented next:", 
            "title": "Non-Parameterized"
        }, 
        {
            "location": "/Non-Parameterized/#integration", 
            "text": "According to item 1 on the homepage, four different constellations of the two triangles are possible:   Equal triangles $\\to$ Common Face  Two vertices in common $\\to$ Common Edge  One vertex in common $\\to$ Common Vertex  Both triangles do not touch at all $\\to$ Positive Distance    As each of those four constellations has its own integration method (because of a possible singularity in the kernel), the function  sauterschwabintegral()  has to call another function, which handles the situation suitably; hence it has four methods.  In the case  sauterschwabintegral()  has to deal with a situation mentioned in the first three cases, the two area-integrals will be transformed to four 1D integrals from zero to one;  accuracy  gives the number of quadrature points on that integration path, therefore  accuracy  is of type unsigned Int64. In the case  sauterschwabintegral()  has to deal with a situation of the last case,  accuracy_pd  \u2013 which is again a type of unsigned Int64 \u2013 will be considered. It is a rule of how many quadrature points are created on both triangles.  accuracy_pd  =   1 $\\to$ 1  2 $\\to$ 3  3 $\\to$ 4  4 $\\to$ 6  5 $\\to$ 7  6 $\\to$ 12  7 $\\to$ 13  8 $\\to$ 36  9 $\\to$ 79  10 $\\to$ 105  11 $\\to$ 120  12 $\\to$ 400  13 $\\to$ 900   quadrature point(s) is(are) created on both triangles.    The user is now able to understand the examples in the '...non_parameterized.jl' files, rather their titles. The order of the points within the two  simplex()  functions of  Sourcechart  and  Testchart  can be changed arbitrarily, the result will always remain the same. For those who are interested in the 'called function' or want to skip  sauterschwabintegral()  and call the integration directly \u2013 which is actually only a sorting process \u2013 may read on now.    The called function by  sauterschwabintegral()  is:  sauterschwab_nonparameterized(sourcechart, testchart, integrand, method) .  sourcechart  and  testchart  are the modified versions of the original charts, the  integrand  is the same as at the beginning, and  method  is that created object. The type of  method  is responsible for which method of  sauterschwab_nonparameterized  is applied. The four methods will be listed now:", 
            "title": "Integration"
        }, 
        {
            "location": "/Non-Parameterized/#common-face", 
            "text": "$\\Gamma$ and $\\Gamma'$ are equal, hence  sourcechart  and  testchart  are equal as well. The two charts have to be created by  testchart = sourcechart = simplex(P1,P2,P3) ,  where  P1 ,  P2  and  P3  are the vertices of that particular triangle. Note that both charts must be equal, that means that the first argument of both charts must be equal, the second argument of both charts must be equal, and the last argument of both charts must be equal.  The last argument can be created by  cf = CommonFace(x) .  cf  is an object of type  CommonFace() , x is the number of quadrature points on the integration path $[0,1]$.  An example of this case can be found at the end of the common_face_non_parameterized.jl file in the example folder.", 
            "title": "Common Face"
        }, 
        {
            "location": "/Non-Parameterized/#common-edge", 
            "text": "$\\Gamma$ and $\\Gamma'$ are now different, hence  sourcechart  and  testchart  are different as well. The two charts have to be created in the following manner:  testchart = simplex(P1,P2,P3); sourcechart = simplex(P1,P4,P3) .  Again the order of the input arguments must be taken into account: The first argument of both charts must be equal, and the last argument of both charts must be equal. Consequently the first and the last argument are the vertices which both triangles have in common.  The last argument can be created by  ce = CommonEdge(x) .  ce  is an object of type  CommonEdge() , x is the number of quadrature points on the integration path $[0,1]$.  An example of this case can be found at the end of the common_edge_non_parameterized.jl file in the example folder.", 
            "title": "Common Edge"
        }, 
        {
            "location": "/Non-Parameterized/#common-vertex", 
            "text": "The two triangles and charts are again different. The two charts have to be created in the following manner:  sourcechart = simplex(P1,P2,P3); testchart = simplex(P1,P4,P5) .  Again the order of the input arguments must be taken into account: The first argument of both charts must be equal, the order of  P2  and  P3  with respect to  sourcechart  and the order of  P4  and  P5  with respect to  testchart  does not matter.  Consequently, the first argument is the vertex both triangles have in common.  The last argument is created by  cv = CommonVertex(x) .  cv  is an object of type  CommonVertex() , x is the number of quadrature points on the integration path $[0,1]$.  An example of this case can be found at the end of the common_vertex_non_parameterized.jl file in the example folder.", 
            "title": "Common Vertex"
        }, 
        {
            "location": "/Non-Parameterized/#positive-distance", 
            "text": "As the triangles do not touch at all, the integration becomes a simple quadrature. Therefore the order of the arguments within the two  simplexfunction() 's no longer matter.  The last argument can be created by  pd = PositiveDistance(x) .  pd  is an object of type  PositiveDistance() , x is the rule of how many quadrature points are created on both triangles.  An example of this case can be found at the end of the positive_distance_non_parameterized.jl file in the example folder.", 
            "title": "Positive Distance"
        }, 
        {
            "location": "/Parameterized/", 
            "text": "Parameterized\n\n\nThe called function in this implementation looks like:\n\n\nsauterschwab_parameterized(sourcechart, testchart, integrand, method)\n\n\nAs on the homepage already mentioned, the user has now to parameterize the integration areas by himself; that means that \nintegrand\n is no more the original function which has to be integrated; \nintegrand\n is now the parameterized version of the original integrand including the two surface elements of both charts.\n\n\nBefore the parameterizations/charts (parameterization = chart) are built, the user has to figure out, which integration method should be applied, and decide how accurate the integration shall be done. It is recommended that the user read the page 'Non-Parameterized' before he continues reading here because otherwise he may not be able to apply the concepts of 'integration method' and 'accuracy'.\n\n\nThe parameterization of the sourcetriangle will be called $\\chi_t$, and the parameterization of the testtriangle will be called $\\chi_\\tau$. In the following, the parameterization of every single integration method will be presented.\n\n\n\n\nCommon Face\n\n\n$\\Gamma$ and $\\Gamma'$ are equal, and both parameterizations must be equal as well: $\\chi_t(u',v') = \\chi_\\tau(u,v)$.\n\n\n\n\nThe user's task is to find a parameterization, which maps the reference triangle (right) on to the real triangle (left). The reference triangle is throughout this package always the same.\n\n\nThat parameterization is a function, which corresponds to the input arguments \nsoucechart\n and \ntestchart\n.\n\n\nThe original integrand, which is a function of $\\textbf{x}$ and $\\textbf{y}$, becomes:\n\n\n\n\n\nf(\\chi_\\tau(u,v),\\chi_t(u',v')) \\cdot \\|\\frac{\\partial \\chi_\\tau}{\\partial u}\\times\\frac{\\partial \\chi_\\tau}{\\partial v}\\| \\cdot\\|\\frac{\\partial \\chi_t}{\\partial u'}\\times\\frac{\\partial \\chi_t}{\\partial v'}\\|\n\n\n\n\n\nThis function method as well as the following methods, transform the two area-integrals in parameters domain into four 1D integrals from zero to one, therefore the last argument can be created by\n\n\ncf = CommonFace(x)\n.\n\n\ncf\n is an object of type \nCommonFace()\n, x is the number of quadrature points on the integration path $[0,1]$.\n\n\nAn example of this case can be found in the common_face_parameterized.jl file in the example folder.\n\n\n\n\nCommon Edge\n\n\n$\\Gamma$ and $\\Gamma'$ have an edge in common, and both parameterizations must fulfill the condition $\\chi_t(s,0) = \\chi_\\tau(s,0)$. For example, this condition could be met if the points $(u\\in[0,1];0)$ and $(u'\\in[0,1];0)$ are mapped on the same point on the common edge.\n\n\n\n\nThe parameterizations are functions, which correspond to the input arguments \nsoucechart\n and \ntestchart\n.\n\n\nThe modified integrand looks like in the case Common Face.\n\n\nThe last argument can be created by\n\n\nce = CommonEdge(x)\n.\n\n\nce\n is an object of type \nCommonEdge()\n, x is the number of quadrature points on the integration path $[0,1]$.\n\n\nAn example of this case can be found in the common_edge_parameterized.jl file in the example folder.\n\n\n\n\nCommon Vertex\n\n\n$\\Gamma$ and $\\Gamma'$ have one vertex in common, and both parameterizations must fulfill the condition $\\chi_t(0,0) = \\chi_\\tau(0,0)$. This condition means that the origin of both reference triangles is mapped on the common vertex.\n\n\n\n\nThe parameterizations are functions, which correspond to the input arguments \nsoucechart\n and \ntestchart\n.\n\n\nThe modified integrand looks like in the case Common Face.\n\n\nThe last argument can be created by\n\n\ncv = CommonVertex(x)\n.\n\n\ncv\n is an object of type \nCommonVertex()\n, x is the number of quadrature points on the integration path $[0,1]$.\n\n\nAn example of this case can be found in the common_vertex_parameterized.jl file in the example folder.\n\n\n\n\nPositive Distance\n\n\nThe two triangles do not touch at all, and both parameterizations need only to map from the reference triangle on to the real triangle.\n\n\n\n\nThe parameterizations are functions, which correspond to the input arguments \nsoucechart\n and \ntestchart\n.\n\n\nThe modified integrand looks like in the case Common Face.\n\n\nThe last argument can be created by\n\n\npd = PositiveDistance(x)\n.\n\n\npd\n is an object of type \nPositiveDistance()\n, x is the number of quadrature points on the integration path $[0,1]$.\n\n\nAn example of this case can be found in the positive_distance_parameterized.jl file in the example folder.", 
            "title": "Parameterized"
        }, 
        {
            "location": "/Parameterized/#parameterized", 
            "text": "The called function in this implementation looks like:  sauterschwab_parameterized(sourcechart, testchart, integrand, method)  As on the homepage already mentioned, the user has now to parameterize the integration areas by himself; that means that  integrand  is no more the original function which has to be integrated;  integrand  is now the parameterized version of the original integrand including the two surface elements of both charts.  Before the parameterizations/charts (parameterization = chart) are built, the user has to figure out, which integration method should be applied, and decide how accurate the integration shall be done. It is recommended that the user read the page 'Non-Parameterized' before he continues reading here because otherwise he may not be able to apply the concepts of 'integration method' and 'accuracy'.  The parameterization of the sourcetriangle will be called $\\chi_t$, and the parameterization of the testtriangle will be called $\\chi_\\tau$. In the following, the parameterization of every single integration method will be presented.", 
            "title": "Parameterized"
        }, 
        {
            "location": "/Parameterized/#common-face", 
            "text": "$\\Gamma$ and $\\Gamma'$ are equal, and both parameterizations must be equal as well: $\\chi_t(u',v') = \\chi_\\tau(u,v)$.   The user's task is to find a parameterization, which maps the reference triangle (right) on to the real triangle (left). The reference triangle is throughout this package always the same.  That parameterization is a function, which corresponds to the input arguments  soucechart  and  testchart .  The original integrand, which is a function of $\\textbf{x}$ and $\\textbf{y}$, becomes:   \nf(\\chi_\\tau(u,v),\\chi_t(u',v')) \\cdot \\|\\frac{\\partial \\chi_\\tau}{\\partial u}\\times\\frac{\\partial \\chi_\\tau}{\\partial v}\\| \\cdot\\|\\frac{\\partial \\chi_t}{\\partial u'}\\times\\frac{\\partial \\chi_t}{\\partial v'}\\|   This function method as well as the following methods, transform the two area-integrals in parameters domain into four 1D integrals from zero to one, therefore the last argument can be created by  cf = CommonFace(x) .  cf  is an object of type  CommonFace() , x is the number of quadrature points on the integration path $[0,1]$.  An example of this case can be found in the common_face_parameterized.jl file in the example folder.", 
            "title": "Common Face"
        }, 
        {
            "location": "/Parameterized/#common-edge", 
            "text": "$\\Gamma$ and $\\Gamma'$ have an edge in common, and both parameterizations must fulfill the condition $\\chi_t(s,0) = \\chi_\\tau(s,0)$. For example, this condition could be met if the points $(u\\in[0,1];0)$ and $(u'\\in[0,1];0)$ are mapped on the same point on the common edge.   The parameterizations are functions, which correspond to the input arguments  soucechart  and  testchart .  The modified integrand looks like in the case Common Face.  The last argument can be created by  ce = CommonEdge(x) .  ce  is an object of type  CommonEdge() , x is the number of quadrature points on the integration path $[0,1]$.  An example of this case can be found in the common_edge_parameterized.jl file in the example folder.", 
            "title": "Common Edge"
        }, 
        {
            "location": "/Parameterized/#common-vertex", 
            "text": "$\\Gamma$ and $\\Gamma'$ have one vertex in common, and both parameterizations must fulfill the condition $\\chi_t(0,0) = \\chi_\\tau(0,0)$. This condition means that the origin of both reference triangles is mapped on the common vertex.   The parameterizations are functions, which correspond to the input arguments  soucechart  and  testchart .  The modified integrand looks like in the case Common Face.  The last argument can be created by  cv = CommonVertex(x) .  cv  is an object of type  CommonVertex() , x is the number of quadrature points on the integration path $[0,1]$.  An example of this case can be found in the common_vertex_parameterized.jl file in the example folder.", 
            "title": "Common Vertex"
        }, 
        {
            "location": "/Parameterized/#positive-distance", 
            "text": "The two triangles do not touch at all, and both parameterizations need only to map from the reference triangle on to the real triangle.   The parameterizations are functions, which correspond to the input arguments  soucechart  and  testchart .  The modified integrand looks like in the case Common Face.  The last argument can be created by  pd = PositiveDistance(x) .  pd  is an object of type  PositiveDistance() , x is the number of quadrature points on the integration path $[0,1]$.  An example of this case can be found in the positive_distance_parameterized.jl file in the example folder.", 
            "title": "Positive Distance"
        }
    ]
}