{
    "docs": [
        {
            "location": "/", 
            "text": "SauterSchwabQuadrature.jl\n\n\nThis package can be used to solve problems of following type:\n\n\n\n\n\n\\int_{\\Gamma}\\int_{\\Gamma'}b_i(\\textbf{x})\\,k(\\textbf{x},\\textbf{y})\\, b_j(\\textbf{y})\\;da_\\textbf{y}\\,da_\\textbf{x}\n\n\n\n\n\nThe above expression is a double area-integral over two flat triangles $\\Gamma$ and $\\Gamma'$ in 3D Space. The integrand consists of two basisfunctions $b_i(\\textbf{x})$ and $b_i(\\textbf{y})$ and the kernel $k(\\textbf{x},\\textbf{y})$.   \n\n\nThis kind of integral often appears in the area of Boundary Element Methods for solving elliptic partial differential equations, and can be interpretated as the interaction of the two basisfunctions on their respective triangles. Therefore in this package the two triangles are called test- and sourcecell, and the same goes for the two basefunctions, they are called test- and sourcefunction. The triangles correspond to the cells of a meshed surface.\n\n\nAs the solving algorithm works for a wide range of basisfunctions and kernels, all the requirements for the kernel, basisfunctions and the integration areas will be given:\n\n\n1.Requirements for the triangles:\n\n\n\n\nThe triangles must be flat and are created by three vertices\n\n\nThe triangles must be either the same, or have two vertices in common, or have one vertex in common or they do not touch at all; A partial overlap is forbidden\n\n\n\n\n2.Requirements for the basisfunctions:\n\n\n\n\nThe basisfunctions must be real and non singular on their respective triangles\n\n\nThe basisfunctions map vectors on scalars\n\n\n\n\n3.The kernel must be Cauchy-Singular\n\n\nAccording to item 1, four different constellations of the two triangles are possible:\n\n\n\n\nEqual triangles $\\to$ Common Face\n\n\nTwo vertices in common $\\to$ Common Edge\n\n\nOne vertex in commmon $\\to$ Common Vertex\n\n\nBoth triangles do not touch at all $\\to$ Positive Distance\n\n\n\n\nAs each of those four constellations has its own integration method (because of a possible singularity in the kernel), every single case will be presented using an example. However, in all four cases the called function will look like:\n\n\nsauterschwabintegral(sourcechart, testchart, integrand, constellation)\n\n\n\n\n\nsourcechart\n and \ntestchart\n are the mappings from a reference triangle to the real triangles in space, they contain the information of the positions of both triangles. \nintegrand\n is the integrand and \nconstellation\n is a object of a particular type which conveys the function the method of integration and additional information of how accurate the integration shall be done.\n\n\nAs this package depends on CompScienceMeshes, it is useful to know about that package, at least about the functions \nsimplex()\n and \npoint()\n.\n\n\nThis documentation does not derive the integration rules and how the integration is done, it only shows how to handle this package. If the user wants to know more about how this package operates, he has to go inside the src folder and look up for the book in the README file.\n\n\n\n\nCommon Face\n\n\n$\\Gamma$ and $\\Gamma'$ are equal, hence \nsourcechart\n and \ntestchart\n are equal as well. The two charts can be created by\n\n\ntestchart = sourcechart = simplex(P1,P2,P3)\n ```\n , where `P1`, `P2` and `P3` are the vertices of that particular triangle. Note that both charts must be equal, that means that the first argument of both charts must be euqal, the second argument of both charts must be euqal, and the last argument of both charts must be equal. For instance `sourcechart = simplex(P1,P2,P3)` and  `testchart = simplex(P1,P3,P2)` will not work because of the different orders of the input arguments.\n\n The `integrand` must be defined as a function and its function name is the input argument.\n\n The last argument can be created by\n\n\n\n\n\ncf = CommonFace(x)\n\n\n. `cf` is an object of type `CommonFace()`, x is an integer which stands for the degree of accuracy. The larger x is, the more accurate the evaluation will be.\n\nAn example of this case can be found and run in the example folder.\n\n\n## Common Edge\n\n$\\Gamma$ and $\\Gamma\n$ are now different, hence `sourcechart` and `testchart` are different as well. The two charts have to be created in the following manner:\n\n\n\n\n\ntestchart = simplex(P1,P2,P3) sourcechart = simplex(P1,P4,P3)\n\n\n.Again\n \nthe\n \norder\n \nof\n \nthe\n \ninput\n \narguments\n \nmust\n \nbe\n \ntaken\n \ninto\n \naccount\n:\n \nThe\n \nfirst\n \nargument\n \nof\n \nboth\n \ncharts\n \nmust\n \nbe\n \nequal\n,\n \nand\n \nthe\n \nlast\n \nargument\n \nof\n \nboth\n \ncharts\n \nmust\n \nbe\n \nequal.\n \nConsequently\n \nthe\n \nfirst\n \nand\n \nthe\n \nlast\n \nargument\n \nare\n \nthe\n \nvertices\n \nwhich\n \nboth\n \ntriangles\n \nhave\n \nin\n \ncommon.\n\n\n  \nThe\n \n`\nintegrand\n`\n \nmust\n \nbe\n \ndefined\n \nas\n \na\n \nfunction\n \nand\n \nits\n \nfunction\n \nname\n \nis\n \nthe\n \ninput\n \nargument.\n\n\n \nThe\n \nlast\n \nargument\n \ncan\n \nbe\n \ncreated\n \nby\n\n\n\n\n\n\nce = CommonEdge(x)\n\n\n. `ce` is an object of type `CommonEdge()`, x is an integer which stands for the degree of accuracy. The larger x is, the more accurate the evaluation will be.\n\nAn example of this case can be found and run in the example folder.\n\n\n# Common Vertex\n\nThe two triangles and charts are again different. The two charts have to be created in the following manner:\n\n\n\n\n\nsourcechart = simplex(P1,P2,P3) testchart = simplex(P1,P4,P5)\n\n\n.Again\n \nthe\n \norder\n \nof\n \nthe\n \ninput\n \narguments\n \nmust\n \nbe\n \ntaken\n \ninto\n \naccount\n:\n \nThe\n \nfirst\n \nargument\n \nof\n \nboth\n \ncharts\n \nmust\n \nbe\n \nequal\n,\n \nthe\n \norder\n \nof\n \n`\nP2\n`\n \nand\n \n`\nP3\n`\n \nwith\n \nrespect\n \nto\n \n`\nsourcechart\n`\n \nand\n \nthe\n \norder\n \nof\n \n`\nP4\n`\n \nand\n \n`\nP5\n`\n \nwith\n \nrespect\n \nto\n \n`\ntestchart\n`\n \ndoes\n \nnot\n \nmatter.\n  \nConsequently\n,\n \nthe\n \nfirst\n \nargument\n \nis\n \nthe\n \nvertex\n \nboth\n \ntriangles\n \nhave\n \nin\n \ncommon.\n\n\n\nThe\n \n`\nintegrand\n`\n \nmust\n \nbe\n \ndefined\n \nas\n \na\n \nfunction\n \nand\n \nits\n \nfunction\n \nname\n \nis\n \nthe\n \ninput\n \nargument.\n\n\n\nThe\n \nlast\n \nargument\n \ncan\n \nbe\n \ncreated\n \nby\n\n\n\n\n\n\ncv = CommonVertex(x) \n``.\ncv\nis an object of type\nCommonVertex()`, x is an integer which stands for the degree of accuracy. The larger x is, the more accurate the evaluation will be.\n\n\nAn example of this case can be found and run in the example folder.", 
            "title": "Home"
        }, 
        {
            "location": "/#sauterschwabquadraturejl", 
            "text": "This package can be used to solve problems of following type:   \n\\int_{\\Gamma}\\int_{\\Gamma'}b_i(\\textbf{x})\\,k(\\textbf{x},\\textbf{y})\\, b_j(\\textbf{y})\\;da_\\textbf{y}\\,da_\\textbf{x}   The above expression is a double area-integral over two flat triangles $\\Gamma$ and $\\Gamma'$ in 3D Space. The integrand consists of two basisfunctions $b_i(\\textbf{x})$ and $b_i(\\textbf{y})$ and the kernel $k(\\textbf{x},\\textbf{y})$.     This kind of integral often appears in the area of Boundary Element Methods for solving elliptic partial differential equations, and can be interpretated as the interaction of the two basisfunctions on their respective triangles. Therefore in this package the two triangles are called test- and sourcecell, and the same goes for the two basefunctions, they are called test- and sourcefunction. The triangles correspond to the cells of a meshed surface.  As the solving algorithm works for a wide range of basisfunctions and kernels, all the requirements for the kernel, basisfunctions and the integration areas will be given:  1.Requirements for the triangles:   The triangles must be flat and are created by three vertices  The triangles must be either the same, or have two vertices in common, or have one vertex in common or they do not touch at all; A partial overlap is forbidden   2.Requirements for the basisfunctions:   The basisfunctions must be real and non singular on their respective triangles  The basisfunctions map vectors on scalars   3.The kernel must be Cauchy-Singular  According to item 1, four different constellations of the two triangles are possible:   Equal triangles $\\to$ Common Face  Two vertices in common $\\to$ Common Edge  One vertex in commmon $\\to$ Common Vertex  Both triangles do not touch at all $\\to$ Positive Distance   As each of those four constellations has its own integration method (because of a possible singularity in the kernel), every single case will be presented using an example. However, in all four cases the called function will look like:  sauterschwabintegral(sourcechart, testchart, integrand, constellation)  sourcechart  and  testchart  are the mappings from a reference triangle to the real triangles in space, they contain the information of the positions of both triangles.  integrand  is the integrand and  constellation  is a object of a particular type which conveys the function the method of integration and additional information of how accurate the integration shall be done.  As this package depends on CompScienceMeshes, it is useful to know about that package, at least about the functions  simplex()  and  point() .  This documentation does not derive the integration rules and how the integration is done, it only shows how to handle this package. If the user wants to know more about how this package operates, he has to go inside the src folder and look up for the book in the README file.", 
            "title": "SauterSchwabQuadrature.jl"
        }, 
        {
            "location": "/#common-face", 
            "text": "$\\Gamma$ and $\\Gamma'$ are equal, hence  sourcechart  and  testchart  are equal as well. The two charts can be created by  testchart = sourcechart = simplex(P1,P2,P3)\n ```\n , where `P1`, `P2` and `P3` are the vertices of that particular triangle. Note that both charts must be equal, that means that the first argument of both charts must be euqal, the second argument of both charts must be euqal, and the last argument of both charts must be equal. For instance `sourcechart = simplex(P1,P2,P3)` and  `testchart = simplex(P1,P3,P2)` will not work because of the different orders of the input arguments.\n\n The `integrand` must be defined as a function and its function name is the input argument.\n\n The last argument can be created by  cf = CommonFace(x)  . `cf` is an object of type `CommonFace()`, x is an integer which stands for the degree of accuracy. The larger x is, the more accurate the evaluation will be.\n\nAn example of this case can be found and run in the example folder.\n\n\n## Common Edge\n\n$\\Gamma$ and $\\Gamma $ are now different, hence `sourcechart` and `testchart` are different as well. The two charts have to be created in the following manner:  testchart = simplex(P1,P2,P3) sourcechart = simplex(P1,P4,P3)  .Again   the   order   of   the   input   arguments   must   be   taken   into   account :   The   first   argument   of   both   charts   must   be   equal ,   and   the   last   argument   of   both   charts   must   be   equal.   Consequently   the   first   and   the   last   argument   are   the   vertices   which   both   triangles   have   in   common. \n\n   The   ` integrand `   must   be   defined   as   a   function   and   its   function   name   is   the   input   argument. \n\n  The   last   argument   can   be   created   by   ce = CommonEdge(x)  . `ce` is an object of type `CommonEdge()`, x is an integer which stands for the degree of accuracy. The larger x is, the more accurate the evaluation will be.\n\nAn example of this case can be found and run in the example folder.\n\n\n# Common Vertex\n\nThe two triangles and charts are again different. The two charts have to be created in the following manner:  sourcechart = simplex(P1,P2,P3) testchart = simplex(P1,P4,P5)  .Again   the   order   of   the   input   arguments   must   be   taken   into   account :   The   first   argument   of   both   charts   must   be   equal ,   the   order   of   ` P2 `   and   ` P3 `   with   respect   to   ` sourcechart `   and   the   order   of   ` P4 `   and   ` P5 `   with   respect   to   ` testchart `   does   not   matter.    Consequently ,   the   first   argument   is   the   vertex   both   triangles   have   in   common.  The   ` integrand `   must   be   defined   as   a   function   and   its   function   name   is   the   input   argument.  The   last   argument   can   be   created   by   cv = CommonVertex(x)  ``. cv is an object of type CommonVertex()`, x is an integer which stands for the degree of accuracy. The larger x is, the more accurate the evaluation will be.  An example of this case can be found and run in the example folder.", 
            "title": "Common Face"
        }, 
        {
            "location": "/test/", 
            "text": "Better Greeting :-)", 
            "title": "Tutorials"
        }, 
        {
            "location": "/test/#better-greeting-", 
            "text": "", 
            "title": "Better Greeting :-)"
        }
    ]
}